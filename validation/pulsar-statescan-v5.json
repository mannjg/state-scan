{
  "metadata" : {
    "projectPath" : "/home/jmann/git/pulsar",
    "scanDate" : "2025-12-02T16:02:57.160515691",
    "classesScanned" : 129197,
    "jarsScanned" : 185,
    "scanDurationMs" : 24583
  },
  "summary" : {
    "critical" : 76,
    "high" : 178,
    "medium" : 16,
    "low" : 3,
    "info" : 5,
    "total" : 278
  },
  "findings" : [ {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentTopic",
    "simpleClassName" : "PersistentTopic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "strategicCompactionMap",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static non-final field 'strategicCompactionMap' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentTopic",
    "simpleClassName" : "PersistentTopic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "threadLocalTopicStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'threadLocalTopicStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.flume.source.AbstractSinkOfFlume",
    "simpleClassName" : "AbstractSinkOfFlume",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "records",
    "fieldType" : "Ljava/util/concurrent/BlockingQueue;",
    "description" : "Static non-final field 'records' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.bookkeeper.LegacyHierarchicalLedgerRangeIterator",
    "simpleClassName" : "LegacyHierarchicalLedgerRangeIterator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "threadLocalNodeBuilder",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Static final field 'threadLocalNodeBuilder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceProducer",
    "simpleClassName" : "PerformanceProducer",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "recorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'recorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceProducer",
    "simpleClassName" : "PerformanceProducer",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "messageFormatter",
    "fieldType" : "Lorg/apache/pulsar/testclient/IMessageFormatter;",
    "description" : "Static non-final field 'messageFormatter' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceProducer",
    "simpleClassName" : "PerformanceProducer",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "cumulativeRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'cumulativeRecorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.ReplicatedSubscriptionsSnapshotBuilder",
    "simpleClassName" : "ReplicatedSubscriptionsSnapshotBuilder",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Summary)",
    "fieldName" : "SNAPSHOT_METRIC",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static final field 'SNAPSHOT_METRIC' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.structuredeventlog.slf4j.Slf4jEvent",
    "simpleClassName" : "Slf4jEvent",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "loggersTLS",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Static final field 'loggersTLS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.structuredeventlog.slf4j.Slf4jEvent",
    "simpleClassName" : "Slf4jEvent",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "$SWITCH_TABLE$org$apache$pulsar$structuredeventlog$slf4j$Slf4jEvent$Level",
    "fieldType" : "[I",
    "description" : "Static non-final field '$SWITCH_TABLE$org$apache$pulsar$structuredeventlog$slf4j$Slf4jEvent$Level' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.crypto.MessageCryptoBc",
    "simpleClassName" : "MessageCryptoBc",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "keyGenerator",
    "fieldType" : "Ljavax/crypto/KeyGenerator;",
    "description" : "Static non-final field 'keyGenerator' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.LastCumulativeAck",
    "simpleClassName" : "LastCumulativeAck",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "LOCAL_LAST_CUMULATIVE_ACK",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'LOCAL_LAST_CUMULATIVE_ACK' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceConsumer",
    "simpleClassName" : "PerformanceConsumer",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "cumulativeRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'cumulativeRecorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceConsumer",
    "simpleClassName" : "PerformanceConsumer",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "recorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'recorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.stats.JvmDefaultGCMetricsLogger",
    "simpleClassName" : "JvmDefaultGCMetricsLogger",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "runtime",
    "fieldType" : "Ljava/lang/Object;",
    "description" : "Static non-final field 'runtime' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator",
    "simpleClassName" : "KubernetesSecretsProviderConfigurator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "keyKey",
    "fieldType" : "Ljava/lang/String;",
    "description" : "Static non-final field 'keyKey' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator",
    "simpleClassName" : "KubernetesSecretsProviderConfigurator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "idKey",
    "fieldType" : "Ljava/lang/String;",
    "description" : "Static non-final field 'idKey' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.LocalMemoryMetadataStore",
    "simpleClassName" : "LocalMemoryMetadataStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "STATIC_MAPS",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'STATIC_MAPS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.LocalMemoryMetadataStore",
    "simpleClassName" : "LocalMemoryMetadataStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "STATIC_ID_GEN_MAP",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'STATIC_ID_GEN_MAP' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.LocalMemoryMetadataStore",
    "simpleClassName" : "LocalMemoryMetadataStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "STATIC_INSTANCE",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'STATIC_INSTANCE' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitState",
    "simpleClassName" : "ServiceUnitState",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "inFlightStates",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'inFlightStates' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitState",
    "simpleClassName" : "ServiceUnitState",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "validTransitionsOverSystemTopic",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'validTransitionsOverSystemTopic' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitState",
    "simpleClassName" : "ServiceUnitState",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "validTransitionsOverMetadataStore",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'validTransitionsOverMetadataStore' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.PortManager",
    "simpleClassName" : "PortManager",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "PORTS",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'PORTS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.limiter.ConnectionController$DefaultConnectionController",
    "simpleClassName" : "ConnectionController$DefaultConnectionController",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "CONNECTIONS",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'CONNECTIONS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.limiter.ConnectionController$DefaultConnectionController",
    "simpleClassName" : "ConnectionController$DefaultConnectionController",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "totalConnectionNum",
    "fieldType" : "I",
    "description" : "Static non-final field 'totalConnectionNum' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.MetricsExports",
    "simpleClassName" : "MetricsExports",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "initialized",
    "fieldType" : "Z",
    "description" : "Static non-final field 'initialized' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.nonpersistent.NonPersistentStickyKeyDispatcherMultipleConsumers",
    "simpleClassName" : "NonPersistentStickyKeyDispatcherMultipleConsumers",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localGroupedEntries",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localGroupedEntries' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.nonpersistent.NonPersistentStickyKeyDispatcherMultipleConsumers",
    "simpleClassName" : "NonPersistentStickyKeyDispatcherMultipleConsumers",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localGroupedStickyKeyHashes",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localGroupedStickyKeyHashes' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.BrokerMonitor",
    "simpleClassName" : "BrokerMonitor",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "SYSTEM_FIELDS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'SYSTEM_FIELDS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.BrokerMonitor",
    "simpleClassName" : "BrokerMonitor",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "MESSAGE_FIELDS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'MESSAGE_FIELDS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.AuthenticationProviderToken",
    "simpleClassName" : "AuthenticationProviderToken",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "expiredTokenMetrics",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'expiredTokenMetrics' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.AuthenticationProviderToken",
    "simpleClassName" : "AuthenticationProviderToken",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "expiringTokenMinutesMetrics",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'expiringTokenMinutesMetrics' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.ServerCnx$PendingBytesPerThreadTracker",
    "simpleClassName" : "ServerCnx$PendingBytesPerThreadTracker",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "pendingBytesPerThread",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'pendingBytesPerThread' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.web.WebExecutorStats",
    "simpleClassName" : "WebExecutorStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "CLOSED",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicBoolean;",
    "description" : "Static final field 'CLOSED' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.UnAckedMessageTracker",
    "simpleClassName" : "UnAckedMessageTracker",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "TL_MESSAGE_IDS_SET",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'TL_MESSAGE_IDS_SET' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.transaction.coordinator.impl.MLTransactionMetadataStoreProvider",
    "simpleClassName" : "MLTransactionMetadataStoreProvider",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "bufferedWriterMetrics",
    "fieldType" : "Lorg/apache/pulsar/transaction/coordinator/impl/TxnLogBufferedWriterMetricsStats;",
    "description" : "Static non-final field 'bufferedWriterMetrics' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ProxyServiceStarter",
    "simpleClassName" : "ProxyServiceStarter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "metricsInitialized",
    "fieldType" : "Z",
    "description" : "Static non-final field 'metricsInitialized' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.MessageCrypto",
    "simpleClassName" : "MessageCrypto",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "keyGenerator",
    "fieldType" : "Ljavax/crypto/KeyGenerator;",
    "description" : "Static non-final field 'keyGenerator' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.stats.MetadataStoreStats",
    "simpleClassName" : "MetadataStoreStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "PUT_BYTES",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'PUT_BYTES' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.stats.MetadataStoreStats",
    "simpleClassName" : "MetadataStoreStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "OPS_LATENCY",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'OPS_LATENCY' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.SaslRoleToken",
    "simpleClassName" : "SaslRoleToken",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "ATTRIBUTES",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'ATTRIBUTES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "simpleClassName" : "PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localGroupedEntries",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localGroupedEntries' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "simpleClassName" : "PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localGroupedPositions",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localGroupedPositions' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.websocket.ProducerHandler",
    "simpleClassName" : "ProducerHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "ENTRY_LATENCY_BUCKETS_USEC",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'ENTRY_LATENCY_BUCKETS_USEC' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.naming.TopicBundleAssignmentFactory",
    "simpleClassName" : "TopicBundleAssignmentFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "strategy",
    "fieldType" : "Lorg/apache/pulsar/common/naming/TopicBundleAssignmentStrategy;",
    "description" : "Static non-final field 'strategy' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.tests.RetryAnalyzer",
    "simpleClassName" : "RetryAnalyzer",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "CHANGED_TEST_CLASSES",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'CHANGED_TEST_CLASSES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryServiceImpl",
    "simpleClassName" : "SchemaRegistryServiceImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "hashFunction",
    "fieldType" : "Lcom/google/common/hash/HashFunction;",
    "description" : "Static non-final field 'hashFunction' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.api.AuthData",
    "simpleClassName" : "AuthData",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "INIT_AUTH_DATA_BYTES",
    "fieldType" : "[B",
    "description" : "Static non-final field 'INIT_AUTH_DATA_BYTES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.api.AuthData",
    "simpleClassName" : "AuthData",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "REFRESH_AUTH_DATA_BYTES",
    "fieldType" : "[B",
    "description" : "Static non-final field 'REFRESH_AUTH_DATA_BYTES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.SchemaUtils",
    "simpleClassName" : "SchemaUtils",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "SCHEMA_TYPE_CLASSES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'SCHEMA_TYPE_CLASSES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.SchemaUtils",
    "simpleClassName" : "SchemaUtils",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "JAVA_CLASS_SCHEMA_TYPES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'JAVA_CLASS_SCHEMA_TYPES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.PendingAckHandleStatsImpl",
    "simpleClassName" : "PendingAckHandleStatsImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "exposeTopicLevelMetrics0",
    "fieldType" : "Z",
    "description" : "Static non-final field 'exposeTopicLevelMetrics0' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.PendingAckHandleStatsImpl",
    "simpleClassName" : "PendingAckHandleStatsImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "commitTxnCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static non-final field 'commitTxnCounter' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.PendingAckHandleStatsImpl",
    "simpleClassName" : "PendingAckHandleStatsImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "INITIALIZED",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicBoolean;",
    "description" : "Static final field 'INITIALIZED' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.PendingAckHandleStatsImpl",
    "simpleClassName" : "PendingAckHandleStatsImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "commitTxnLatency",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static non-final field 'commitTxnLatency' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.PendingAckHandleStatsImpl",
    "simpleClassName" : "PendingAckHandleStatsImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "abortTxnCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static non-final field 'abortTxnCounter' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.stats.JvmG1GCMetricsLogger",
    "simpleClassName" : "JvmG1GCMetricsLogger",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "oldGenName",
    "fieldType" : "Ljavax/management/ObjectName;",
    "description" : "Static non-final field 'oldGenName' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.stats.JvmG1GCMetricsLogger",
    "simpleClassName" : "JvmG1GCMetricsLogger",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "youngGenName",
    "fieldType" : "Ljavax/management/ObjectName;",
    "description" : "Static non-final field 'youngGenName' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "LOOKUP_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'LOOKUP_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "GET_SCHEMA_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'GET_SCHEMA_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "PARTITIONS_METADATA_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'PARTITIONS_METADATA_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "REJECTED_GET_TOPICS_OF_NAMESPACE_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'REJECTED_GET_TOPICS_OF_NAMESPACE_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "REJECTED_LOOKUP_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'REJECTED_LOOKUP_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "REJECTED_PARTITIONS_METADATA_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'REJECTED_PARTITIONS_METADATA_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.LookupProxyHandler",
    "simpleClassName" : "LookupProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "GET_TOPICS_OF_NAMESPACE_REQUESTS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'GET_TOPICS_OF_NAMESPACE_REQUESTS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntime",
    "simpleClassName" : "KubernetesRuntime",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "TOLERATIONS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'TOLERATIONS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.ConsumerImpl",
    "simpleClassName" : "ConsumerImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "LOCAL_BASE_COMMAND",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'LOCAL_BASE_COMMAND' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.BrokerOperabilityMetrics",
    "simpleClassName" : "BrokerOperabilityMetrics",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "TOPIC_LOAD_FAILED",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'TOPIC_LOAD_FAILED' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.tests.FastThreadLocalStateCleaner",
    "simpleClassName" : "FastThreadLocalStateCleaner",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "SLOW_THREAD_LOCAL_MAP",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Static final field 'SLOW_THREAD_LOCAL_MAP' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroup",
    "simpleClassName" : "ResourceGroup",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgRemoteUsageReportsMessages",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgRemoteUsageReportsMessages' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroup",
    "simpleClassName" : "ResourceGroup",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgLocalUsageReportCount",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgLocalUsageReportCount' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroup",
    "simpleClassName" : "ResourceGroup",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgRemoteUsageReportsBytes",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgRemoteUsageReportsBytes' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.MLPendingAckStore",
    "simpleClassName" : "MLPendingAckStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "batchedMetaThreadLocalForBufferedWriter",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'batchedMetaThreadLocalForBufferedWriter' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.metrics.MetricsUtil",
    "simpleClassName" : "MetricsUtil",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "DEFAULT_AGGREGATION_LABELS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'DEFAULT_AGGREGATION_LABELS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ParserProxyHandler",
    "simpleClassName" : "ParserProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "consumerHashMap",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'consumerHashMap' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ParserProxyHandler",
    "simpleClassName" : "ParserProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "producerHashMap",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'producerHashMap' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntimeFactory",
    "simpleClassName" : "KubernetesRuntimeFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "sleepBetweenRetriesMs",
    "fieldType" : "J",
    "description" : "Static non-final field 'sleepBetweenRetriesMs' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntimeFactory",
    "simpleClassName" : "KubernetesRuntimeFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "numRetries",
    "fieldType" : "I",
    "description" : "Static non-final field 'numRetries' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.rest.TopicsBase",
    "simpleClassName" : "TopicsBase",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "defaultProducerName",
    "fieldType" : "Ljava/lang/String;",
    "description" : "Static non-final field 'defaultProducerName' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.socket.client.PerformanceClient",
    "simpleClassName" : "PerformanceClient",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "messageFormatter",
    "fieldType" : "Lorg/apache/pulsar/testclient/IMessageFormatter;",
    "description" : "Static non-final field 'messageFormatter' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceTransaction",
    "simpleClassName" : "PerformanceTransaction",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "messageSendRCumulativeRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'messageSendRCumulativeRecorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceTransaction",
    "simpleClassName" : "PerformanceTransaction",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "messageAckRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'messageAckRecorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceTransaction",
    "simpleClassName" : "PerformanceTransaction",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "messageSendRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'messageSendRecorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceTransaction",
    "simpleClassName" : "PerformanceTransaction",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Recorder)",
    "fieldName" : "messageAckCumulativeRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static final field 'messageAckCumulativeRecorder' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.instance.JavaInstanceRunnable$BeanPropertiesReader",
    "simpleClassName" : "JavaInstanceRunnable$BeanPropertiesReader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "reader",
    "fieldType" : "Lorg/apache/pulsar/functions/instance/JavaInstanceRunnable$BeanPropertiesReader$MapperBeanReader;",
    "description" : "Static final field 'reader' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.debezium.PulsarDatabaseHistory",
    "simpleClassName" : "PulsarDatabaseHistory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "ALL_FIELDS",
    "fieldType" : "Lio/debezium/config/Field$Set;",
    "description" : "Static final field 'ALL_FIELDS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.influxdb.v1.InfluxDBGenericRecordSink",
    "simpleClassName" : "InfluxDBGenericRecordSink",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "FIELDS_TO_SKIP",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'FIELDS_TO_SKIP' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.reader.AvroReader",
    "simpleClassName" : "AvroReader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "decoders",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Static final field 'decoders' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ProxyService",
    "simpleClassName" : "ProxyService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Gauge)",
    "fieldName" : "ACTIVE_CONNECTIONS",
    "fieldType" : "Lio/prometheus/client/Gauge;",
    "description" : "Static final field 'ACTIVE_CONNECTIONS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ProxyService",
    "simpleClassName" : "ProxyService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "NEW_CONNECTIONS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'NEW_CONNECTIONS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ProxyService",
    "simpleClassName" : "ProxyService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "OPS_COUNTER",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'OPS_COUNTER' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ProxyService",
    "simpleClassName" : "ProxyService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "REJECTED_CONNECTIONS",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'REJECTED_CONNECTIONS' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.ProxyService",
    "simpleClassName" : "ProxyService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "BYTES_COUNTER",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'BYTES_COUNTER' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.functions.proto.Function$FunctionMetaData",
    "simpleClassName" : "Function$FunctionMetaData",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "instanceStatesValueConverter",
    "fieldType" : "Lcom/google/protobuf/Internal$MapAdapter$Converter;",
    "description" : "Static final field 'instanceStatesValueConverter' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.oxia.OxiaMetadataStore",
    "simpleClassName" : "OxiaMetadataStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "IF_RECORD_DOES_NOT_EXIST",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'IF_RECORD_DOES_NOT_EXIST' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.qos.AsyncTokenBucket",
    "simpleClassName" : "AsyncTokenBucket",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "defaultResolutionNanos",
    "fieldType" : "J",
    "description" : "Static non-final field 'defaultResolutionNanos' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.metrics.Summary",
    "simpleClassName" : "Summary",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "LOGGERS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'LOGGERS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.ObjectMapperFactory",
    "simpleClassName" : "ObjectMapperFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "YAML_MAPPER_REFERENCE",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicReference;",
    "description" : "Static final field 'YAML_MAPPER_REFERENCE' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.ObjectMapperFactory",
    "simpleClassName" : "ObjectMapperFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "MAPPER_REFERENCE",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicReference;",
    "description" : "Static final field 'MAPPER_REFERENCE' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.ObjectMapperFactory",
    "simpleClassName" : "ObjectMapperFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "INSTANCE_WITH_INCLUDE_ALWAYS",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicReference;",
    "description" : "Static final field 'INSTANCE_WITH_INCLUDE_ALWAYS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentSubscription",
    "simpleClassName" : "PersistentSubscription",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "NON_REPLICATED_SUBSCRIPTION_CURSOR_PROPERTIES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'NON_REPLICATED_SUBSCRIPTION_CURSOR_PROPERTIES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentSubscription",
    "simpleClassName" : "PersistentSubscription",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "REPLICATED_SUBSCRIPTION_CURSOR_PROPERTIES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'REPLICATED_SUBSCRIPTION_CURSOR_PROPERTIES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.SendMessageInfo",
    "simpleClassName" : "SendMessageInfo",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "THREAD_LOCAL",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'THREAD_LOCAL' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.bcloader.BouncyCastleLoader",
    "simpleClassName" : "BouncyCastleLoader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "provider",
    "fieldType" : "Ljava/security/Provider;",
    "description" : "Static non-final field 'provider' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.RocksdbMetadataStore",
    "simpleClassName" : "RocksdbMetadataStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "instancesCache",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'instancesCache' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.stats.BatchMetadataStoreStats",
    "simpleClassName" : "BatchMetadataStoreStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Gauge)",
    "fieldName" : "EXECUTOR_QUEUE_SIZE",
    "fieldType" : "Lio/prometheus/client/Gauge;",
    "description" : "Static final field 'EXECUTOR_QUEUE_SIZE' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.stats.BatchMetadataStoreStats",
    "simpleClassName" : "BatchMetadataStoreStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "OPS_WAITING",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'OPS_WAITING' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.stats.BatchMetadataStoreStats",
    "simpleClassName" : "BatchMetadataStoreStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "BATCH_EXECUTE_TIME",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'BATCH_EXECUTE_TIME' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.metadata.impl.stats.BatchMetadataStoreStats",
    "simpleClassName" : "BatchMetadataStoreStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "OPS_PER_BATCH",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'OPS_PER_BATCH' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.TransactionAggregator",
    "simpleClassName" : "TransactionAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localTransactionCoordinatorStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localTransactionCoordinatorStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.TransactionAggregator",
    "simpleClassName" : "TransactionAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localManageLedgerStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localManageLedgerStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.metrics.AuthenticationMetricsToken",
    "simpleClassName" : "AuthenticationMetricsToken",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "expiringTokenMinutesMetrics",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'expiringTokenMinutesMetrics' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.metrics.AuthenticationMetricsToken",
    "simpleClassName" : "AuthenticationMetricsToken",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "TOKEN_DURATION_BUCKET_BOUNDARIES_SECONDS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'TOKEN_DURATION_BUCKET_BOUNDARIES_SECONDS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.metrics.AuthenticationMetricsToken",
    "simpleClassName" : "AuthenticationMetricsToken",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "expiredTokenMetrics",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'expiredTokenMetrics' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.admin.impl.BrokersBase",
    "simpleClassName" : "BrokersBase",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "threadDumpLoggedTimestamp",
    "fieldType" : "J",
    "description" : "Static non-final field 'threadDumpLoggedTimestamp' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.impl.LoadManagerShared",
    "simpleClassName" : "LoadManagerShared",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localSecondaryCache",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localSecondaryCache' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.impl.LoadManagerShared",
    "simpleClassName" : "LoadManagerShared",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localPrimariesCache",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localPrimariesCache' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.sasl.KerberosName",
    "simpleClassName" : "KerberosName",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "defaultRealm",
    "fieldType" : "Ljava/lang/String;",
    "description" : "Static non-final field 'defaultRealm' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.sasl.KerberosName",
    "simpleClassName" : "KerberosName",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "rules",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static non-final field 'rules' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.JSONSchema",
    "simpleClassName" : "JSONSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "JSON_MAPPER",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicReference;",
    "description" : "Static final field 'JSON_MAPPER' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.stats.JvmMetrics",
    "simpleClassName" : "JvmMetrics",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "gcLoggerMap",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'gcLoggerMap' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.naming.TopicName",
    "simpleClassName" : "TopicName",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "cache",
    "fieldType" : "Ljava/util/concurrent/ConcurrentHashMap;",
    "description" : "Static final field 'cache' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.policies.data.OffloadPoliciesImpl",
    "simpleClassName" : "OffloadPoliciesImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "CONFIGURATION_FIELDS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'CONFIGURATION_FIELDS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.DimensionStats",
    "simpleClassName" : "DimensionStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "QUANTILE_LABEL_VALUES",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'QUANTILE_LABEL_VALUES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.DimensionStats",
    "simpleClassName" : "DimensionStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "QUANTILE_LABEL",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'QUANTILE_LABEL' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.cli.converters.ByteUnitUtil",
    "simpleClassName" : "ByteUnitUtil",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "sizeUnit",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static non-final field 'sizeUnit' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.flume.sink.AbstractSink",
    "simpleClassName" : "AbstractSink",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "records",
    "fieldType" : "Ljava/util/concurrent/BlockingQueue;",
    "description" : "Static non-final field 'records' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.namespace.NamespaceService",
    "simpleClassName" : "NamespaceService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "lookupFailures",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'lookupFailures' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.namespace.NamespaceService",
    "simpleClassName" : "NamespaceService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "lookupRedirects",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'lookupRedirects' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.namespace.NamespaceService",
    "simpleClassName" : "NamespaceService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "lookupAnswers",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'lookupAnswers' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator",
    "simpleClassName" : "NamespaceStatsAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localTopicStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localTopicStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator",
    "simpleClassName" : "NamespaceStatsAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localBrokerStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localBrokerStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator",
    "simpleClassName" : "NamespaceStatsAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localNamespaceStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localNamespaceStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.compression.CompressionCodecProvider",
    "simpleClassName" : "CompressionCodecProvider",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "codecs",
    "fieldType" : "Ljava/util/EnumMap;",
    "description" : "Static final field 'codecs' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.SaslAuthenticationState",
    "simpleClassName" : "SaslAuthenticationState",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "stateIdGenerator",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicLong;",
    "description" : "Static final field 'stateIdGenerator' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.api.url.PulsarURLStreamHandlerFactory",
    "simpleClassName" : "PulsarURLStreamHandlerFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "handlers",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'handlers' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.admin.cli.PulsarAdminTool",
    "simpleClassName" : "PulsarAdminTool",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "allowSystemExit",
    "fieldType" : "Z",
    "description" : "Static non-final field 'allowSystemExit' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.admin.cli.PulsarAdminTool",
    "simpleClassName" : "PulsarAdminTool",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "lastExitCode",
    "fieldType" : "I",
    "description" : "Static non-final field 'lastExitCode' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.tests.MockitoThreadLocalStateCleaner",
    "simpleClassName" : "MockitoThreadLocalStateCleaner",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "MOCKING_PROGRESS_PROVIDER",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Static final field 'MOCKING_PROGRESS_PROVIDER' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.FieldParser",
    "simpleClassName" : "FieldParser",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "CONVERTERS",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'CONVERTERS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.FieldParser",
    "simpleClassName" : "FieldParser",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "WRAPPER_TYPES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'WRAPPER_TYPES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerfClientUtils",
    "simpleClassName" : "PerfClientUtils",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "exitProcedure",
    "fieldType" : "Ljava/util/function/Consumer;",
    "description" : "Static non-final field 'exitProcedure' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.LoadSimulationClient",
    "simpleClassName" : "LoadSimulationClient",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "ackListener",
    "fieldType" : "Lorg/apache/pulsar/client/api/MessageListener;",
    "description" : "Static final field 'ackListener' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.tests.TraceTestResourceCleanupListener",
    "simpleClassName" : "TraceTestResourceCleanupListener",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "MODE",
    "fieldType" : "Lorg/apache/pulsar/tests/TraceTestResourceCleanupListener$TraceTestResourceCleanupMode;",
    "description" : "Static final field 'MODE' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.schema.PulsarSchemaToKafkaSchema",
    "simpleClassName" : "PulsarSchemaToKafkaSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Static final cache field",
    "fieldName" : "optionalSchemaCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Static final field 'optionalSchemaCache' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Move to a distributed cache (Redis, Hazelcast) for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.schema.PulsarSchemaToKafkaSchema",
    "simpleClassName" : "PulsarSchemaToKafkaSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Static final cache field",
    "fieldName" : "schemaCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Static final field 'schemaCache' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Move to a distributed cache (Redis, Hazelcast) for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.Reflections",
    "simpleClassName" : "Reflections",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "constructorCache",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'constructorCache' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.Reflections",
    "simpleClassName" : "Reflections",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "PRIMITIVE_NAME_TYPE_MAP",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'PRIMITIVE_NAME_TYPE_MAP' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.metrics.AuthenticationMetrics",
    "simpleClassName" : "AuthenticationMetrics",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "authSuccessMetrics",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'authSuccessMetrics' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.metrics.AuthenticationMetrics",
    "simpleClassName" : "AuthenticationMetrics",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "authFailuresMetrics",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'authFailuresMetrics' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.ServerCnx",
    "simpleClassName" : "ServerCnx",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "cnxsPerThread",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'cnxsPerThread' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.auth.AuthenticationSasl",
    "simpleClassName" : "AuthenticationSasl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "initializedJAAS",
    "fieldType" : "Z",
    "description" : "Static non-final field 'initializedJAAS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.auth.AuthenticationSasl",
    "simpleClassName" : "AuthenticationSasl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "jaasCredentialsContainer",
    "fieldType" : "Lorg/apache/pulsar/common/sasl/JAASCredentialsContainer;",
    "description" : "Static non-final field 'jaasCredentialsContainer' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.api.ConsumerConfiguration",
    "simpleClassName" : "ConsumerConfiguration",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "minAckTimeoutMillis",
    "fieldType" : "J",
    "description" : "Static non-final field 'minAckTimeoutMillis' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.naming.NamespaceBundleSplitAlgorithm",
    "simpleClassName" : "NamespaceBundleSplitAlgorithm",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "AVAILABLE_ALGORITHMS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'AVAILABLE_ALGORITHMS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.transaction.coordinator.impl.MLTransactionLogImpl",
    "simpleClassName" : "MLTransactionLogImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "localBatchedTransactionLogCache",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'localBatchedTransactionLogCache' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.auth.AuthenticationDataTls",
    "simpleClassName" : "AuthenticationDataTls",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "headers",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'headers' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.BrokerService",
    "simpleClassName" : "BrokerService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Gauge)",
    "fieldName" : "throttledConnectionsGauge",
    "fieldType" : "Lio/prometheus/client/Gauge;",
    "description" : "Static final field 'throttledConnectionsGauge' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.BrokerService",
    "simpleClassName" : "BrokerService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Histogram)",
    "fieldName" : "backlogQuotaCheckDuration",
    "fieldType" : "Lio/prometheus/client/Histogram;",
    "description" : "Static final field 'backlogQuotaCheckDuration' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.MessageIdImpl",
    "simpleClassName" : "MessageIdImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "LOCAL_MESSAGE_ID",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'LOCAL_MESSAGE_ID' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceReader",
    "simpleClassName" : "PerformanceReader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "recorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static non-final field 'recorder' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.PerformanceReader",
    "simpleClassName" : "PerformanceReader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "cumulativeRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static non-final field 'cumulativeRecorder' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.web.RateLimitingFilter",
    "simpleClassName" : "RateLimitingFilter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "httpRejectedRequests",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'httpRejectedRequests' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.ManagedLedgerWriter",
    "simpleClassName" : "ManagedLedgerWriter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "recorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static non-final field 'recorder' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.testclient.ManagedLedgerWriter",
    "simpleClassName" : "ManagedLedgerWriter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "cumulativeRecorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static non-final field 'cumulativeRecorder' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.allocator.PulsarByteBufAllocator",
    "simpleClassName" : "PulsarByteBufAllocator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "LISTENERS",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'LISTENERS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.buffer.impl.TransactionBufferClientStatsImpl",
    "simpleClassName" : "TransactionBufferClientStatsImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "instance",
    "fieldType" : "Lorg/apache/pulsar/broker/transaction/buffer/TransactionBufferClientStats;",
    "description" : "Static non-final field 'instance' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.packages.management.core.common.PackageName",
    "simpleClassName" : "PackageName",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Static final cache field",
    "fieldName" : "cache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Static final field 'cache' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Move to a distributed cache (Redis, Hazelcast) for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.kinesis.json.JsonConverter",
    "simpleClassName" : "JsonConverter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "logicalTypeConverters",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'logicalTypeConverters' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.structuredeventlog.log4j2.Log4j2Event",
    "simpleClassName" : "Log4j2Event",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "$SWITCH_TABLE$org$apache$pulsar$structuredeventlog$log4j2$Log4j2Event$Level",
    "fieldType" : "[I",
    "description" : "Static non-final field '$SWITCH_TABLE$org$apache$pulsar$structuredeventlog$log4j2$Log4j2Event$Level' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.LinuxInfoUtils",
    "simpleClassName" : "LinuxInfoUtils",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "metrics",
    "fieldType" : "Ljava/lang/Object;",
    "description" : "Static non-final field 'metrics' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.LinuxInfoUtils",
    "simpleClassName" : "LinuxInfoUtils",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "failedCounterInReadingNicLimits",
    "fieldType" : "Ljava/util/concurrent/atomic/AtomicLong;",
    "description" : "Static final field 'failedCounterInReadingNicLimits' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.server.AdminProxyHandler",
    "simpleClassName" : "AdminProxyHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "functionRoutes",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'functionRoutes' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.nar.NarUnpacker",
    "simpleClassName" : "NarUnpacker",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "CURRENT_JVM_FILE_LOCKS",
    "fieldType" : "Ljava/util/concurrent/ConcurrentHashMap;",
    "description" : "Static final field 'CURRENT_JVM_FILE_LOCKS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.policies.data.loadbalancer.ResourceUnitRanking",
    "simpleClassName" : "ResourceUnitRanking",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "cpuUsageByMsgRate",
    "fieldType" : "D",
    "description" : "Static non-final field 'cpuUsageByMsgRate' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.elasticsearch.JsonConverter",
    "simpleClassName" : "JsonConverter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "logicalTypeConverters",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static non-final field 'logicalTypeConverters' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.AbstractKafkaConnectSource",
    "simpleClassName" : "AbstractKafkaConnectSource",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "PROPERTIES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'PROPERTIES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.proxy.socket.client.SimpleTestProducerSocket",
    "simpleClassName" : "SimpleTestProducerSocket",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "recorder",
    "fieldType" : "Lorg/HdrHistogram/Recorder;",
    "description" : "Static non-final field 'recorder' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.util.SecurityUtility",
    "simpleClassName" : "SecurityUtility",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "KEY_FACTORIES",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'KEY_FACTORIES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.AbstractBaseDispatcher",
    "simpleClassName" : "AbstractBaseDispatcher",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Gauge)",
    "fieldName" : "PENDING_BYTES_TO_DISPATCH",
    "fieldType" : "Lio/prometheus/client/Gauge;",
    "description" : "Static final field 'PENDING_BYTES_TO_DISPATCH' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.extensions.ExtensibleLoadManagerImpl",
    "simpleClassName" : "ExtensibleLoadManagerImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "INTERNAL_TOPICS",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'INTERNAL_TOPICS' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.topics.TopicCompactionStrategy",
    "simpleClassName" : "TopicCompactionStrategy",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "INSTANCES",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'INSTANCES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.web.PulsarWebResource",
    "simpleClassName" : "PulsarWebResource",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Static final cache field",
    "fieldName" : "SERVICE_NAME_RESOLVER_CACHE",
    "fieldType" : "Lcom/github/benmanes/caffeine/cache/LoadingCache;",
    "description" : "Static final field 'SERVICE_NAME_RESOLVER_CACHE' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Move to a distributed cache (Redis, Hazelcast) for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.zookeeper.LocalBookkeeperEnsemble",
    "simpleClassName" : "LocalBookkeeperEnsemble",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "zkSessionTimeOut",
    "fieldType" : "I",
    "description" : "Static non-final field 'zkSessionTimeOut' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.metrics.LatencyHistogram",
    "simpleClassName" : "LatencyHistogram",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "latencyHistogramBuckets",
    "fieldType" : "Ljava/util/List;",
    "description" : "Static final field 'latencyHistogramBuckets' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.common.naming.SystemTopicNames",
    "simpleClassName" : "SystemTopicNames",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "EVENTS_TOPIC_NAMES",
    "fieldType" : "Ljava/util/Set;",
    "description" : "Static final field 'EVENTS_TOPIC_NAMES' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.bcloader.BouncyCastleFipsLoader",
    "simpleClassName" : "BouncyCastleFipsLoader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "provider",
    "fieldType" : "Ljava/security/Provider;",
    "description" : "Static non-final field 'provider' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgNamespaceRegisters",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgNamespaceRegisters' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "maxIntervalForSuppressingReportsMSecs",
    "fieldType" : "J",
    "description" : "Static non-final field 'maxIntervalForSuppressingReportsMSecs' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgNamespaceUnRegisters",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgNamespaceUnRegisters' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgLocalUsageMessages",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgLocalUsageMessages' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgTenantUnRegisters",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgTenantUnRegisters' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Summary)",
    "fieldName" : "rgUsageAggregationLatency",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static final field 'rgUsageAggregationLatency' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgLocalUsageBytes",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgLocalUsageBytes' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgTenantRegisters",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgTenantRegisters' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgCalculatedQuotaMessages",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgCalculatedQuotaMessages' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgCalculatedQuotaBytes",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgCalculatedQuotaBytes' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Summary)",
    "fieldName" : "rgQuotaCalculationLatency",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static final field 'rgQuotaCalculationLatency' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.resourcegroup.ResourceGroupService",
    "simpleClassName" : "ResourceGroupService",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "rgUpdates",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'rgUpdates' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.PulsarClusterMetadataTeardown",
    "simpleClassName" : "PulsarClusterMetadataTeardown",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "localZkNodes",
    "fieldType" : "[Ljava/lang/String;",
    "description" : "Static non-final field 'localZkNodes' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.StringSchema",
    "simpleClassName" : "StringSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "tmpBuffer",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'tmpBuffer' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.ReplicatedSubscriptionsController",
    "simpleClassName" : "ReplicatedSubscriptionsController",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "timedoutSnapshotsMetric",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'timedoutSnapshotsMetric' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.ReplicatedSubscriptionsController",
    "simpleClassName" : "ReplicatedSubscriptionsController",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Gauge)",
    "fieldName" : "pendingSnapshotsMetric",
    "fieldType" : "Lio/prometheus/client/Gauge;",
    "description" : "Static final field 'pendingSnapshotsMetric' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "getOpsFailedCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'getOpsFailedCounter' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Summary)",
    "fieldName" : "putOpsLatency",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static final field 'putOpsLatency' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Summary)",
    "fieldName" : "getOpsLatency",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static final field 'getOpsLatency' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "putOpsFailedCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'putOpsFailedCounter' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "compatibleCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'compatibleCounter' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "deleteOpsFailedCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'deleteOpsFailedCounter' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Summary)",
    "fieldName" : "deleteOpsLatency",
    "fieldType" : "Lio/prometheus/client/Summary;",
    "description" : "Static final field 'deleteOpsLatency' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.schema.SchemaRegistryStats",
    "simpleClassName" : "SchemaRegistryStats",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type (Counter)",
    "fieldName" : "incompatibleCounter",
    "fieldType" : "Lio/prometheus/client/Counter;",
    "description" : "Static final field 'incompatibleCounter' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.MLPendingAckStoreProvider",
    "simpleClassName" : "MLPendingAckStoreProvider",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "bufferedWriterMetrics",
    "fieldType" : "Lorg/apache/pulsar/transaction/coordinator/impl/TxnLogBufferedWriterMetricsStats;",
    "description" : "Static non-final field 'bufferedWriterMetrics' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.systopic.TopicPoliciesSystemTopicClient",
    "simpleClassName" : "TopicPoliciesSystemTopicClient",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "Mutable static field (non-final)",
    "fieldName" : "avroSchema",
    "fieldType" : "Lorg/apache/pulsar/client/api/Schema;",
    "description" : "Static non-final field 'avroSchema' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Make field final if it shouldn't change, or externalize state to a shared store",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.broker.service.nonpersistent.NonPersistentTopic",
    "simpleClassName" : "NonPersistentTopic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static ThreadLocal field",
    "fieldName" : "threadLocalTopicStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Static final field 'threadLocalTopicStats' can be reassigned at runtime. This state is NOT shared across replicas.",
    "recommendation" : "Externalize mutable state to a distributed store for replica consistency",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.io.http.JsonConverter",
    "simpleClassName" : "JsonConverter",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "Static final field with mutable type",
    "fieldName" : "logicalTypeConverters",
    "fieldType" : "Ljava/util/Map;",
    "description" : "Static final field 'logicalTypeConverters' has mutable type that can accumulate state. This state is NOT shared across replicas.",
    "recommendation" : "Consider using a database or distributed data structure instead of in-memory collection",
    "detectorId" : "static-state"
  }, {
    "className" : "org.apache.pulsar.websocket.ConsumerHandler",
    "simpleClassName" : "ConsumerHandler",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "messageIdCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Class 'ConsumerHandler' uses Guava Cache in field 'messageIdCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.reader.AbstractMultiVersionReader",
    "simpleClassName" : "AbstractMultiVersionReader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "readerCache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Class 'AbstractMultiVersionReader' uses Guava Cache in field 'readerCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.KafkaConnectSink",
    "simpleClassName" : "KafkaConnectSink",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "sanitizedTopicCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Class 'KafkaConnectSink' uses Guava Cache in field 'sanitizedTopicCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.KafkaConnectSink",
    "simpleClassName" : "KafkaConnectSink",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "desanitizedTopicCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Class 'KafkaConnectSink' uses Guava Cache in field 'desanitizedTopicCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.generic.MultiVersionSchemaInfoProvider",
    "simpleClassName" : "MultiVersionSchemaInfoProvider",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "cache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Class 'MultiVersionSchemaInfoProvider' uses Guava Cache in field 'cache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.impl.SimpleLoadManagerImpl",
    "simpleClassName" : "SimpleLoadManagerImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "unloadedHotNamespaceCache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Class 'SimpleLoadManagerImpl' uses Guava Cache in field 'unloadedHotNamespaceCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.KafkaConnectSource",
    "simpleClassName" : "KafkaConnectSource",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "readerCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Class 'KafkaConnectSource' uses Guava Cache in field 'readerCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.broker.ManagedLedgerClientFactory",
    "simpleClassName" : "ManagedLedgerClientFactory",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Caffeine Cache",
    "fieldName" : "bkEnsemblePolicyToBkClientMap",
    "fieldType" : "Lcom/github/benmanes/caffeine/cache/AsyncCache;",
    "description" : "Class 'ManagedLedgerClientFactory' uses Caffeine Cache in field 'bkEnsemblePolicyToBkClientMap'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Caffeine Cache with a distributed cache solution: Redis, Hazelcast, or configure Caffeine Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.client.impl.PulsarClientImpl",
    "simpleClassName" : "PulsarClientImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "schemaProviderLoadingCache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Class 'PulsarClientImpl' uses Guava Cache in field 'schemaProviderLoadingCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.schema.PulsarSchemaToKafkaSchema",
    "simpleClassName" : "PulsarSchemaToKafkaSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "optionalSchemaCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Class 'PulsarSchemaToKafkaSchema' uses Guava Cache in field 'optionalSchemaCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.io.kafka.connect.schema.PulsarSchemaToKafkaSchema",
    "simpleClassName" : "PulsarSchemaToKafkaSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "schemaCache",
    "fieldType" : "Lcom/google/common/cache/Cache;",
    "description" : "Class 'PulsarSchemaToKafkaSchema' uses Guava Cache in field 'schemaCache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.functions.instance.ProducerCache",
    "simpleClassName" : "ProducerCache",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Caffeine Cache",
    "fieldName" : "cache",
    "fieldType" : "Lcom/github/benmanes/caffeine/cache/Cache;",
    "description" : "Class 'ProducerCache' uses Caffeine Cache in field 'cache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Caffeine Cache with a distributed cache solution: Redis, Hazelcast, or configure Caffeine Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.broker.authentication.AuthenticationProviderSasl",
    "simpleClassName" : "AuthenticationProviderSasl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Caffeine Cache",
    "fieldName" : "authStates",
    "fieldType" : "Lcom/github/benmanes/caffeine/cache/Cache;",
    "description" : "Class 'AuthenticationProviderSasl' uses Caffeine Cache in field 'authStates'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Caffeine Cache with a distributed cache solution: Redis, Hazelcast, or configure Caffeine Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.io.kafka.AvroSchemaCache",
    "simpleClassName" : "AvroSchemaCache",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "cache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Class 'AvroSchemaCache' uses Guava Cache in field 'cache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.packages.management.core.common.PackageName",
    "simpleClassName" : "PackageName",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Guava Cache",
    "fieldName" : "cache",
    "fieldType" : "Lcom/google/common/cache/LoadingCache;",
    "description" : "Class 'PackageName' uses Guava Cache in field 'cache'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Guava Cache with a distributed cache solution: Redis, Hazelcast, or configure Guava Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.broker.web.PulsarWebResource",
    "simpleClassName" : "PulsarWebResource",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "CRITICAL",
    "pattern" : "In-memory cache: Caffeine Cache",
    "fieldName" : "SERVICE_NAME_RESOLVER_CACHE",
    "fieldType" : "Lcom/github/benmanes/caffeine/cache/LoadingCache;",
    "description" : "Class 'PulsarWebResource' uses Caffeine Cache in field 'SERVICE_NAME_RESOLVER_CACHE'. This cache is local to each replica and will have different data in each instance. Cache invalidations won't propagate across replicas.",
    "recommendation" : "Replace Caffeine Cache with a distributed cache solution: Redis, Hazelcast, or configure Caffeine Cache with a distributed backend. Ensure cache invalidation propagates to all replicas.",
    "detectorId" : "cache"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentTopic",
    "simpleClassName" : "PersistentTopic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "threadLocalTopicStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'PersistentTopic' uses Netty FastThreadLocal in field 'threadLocalTopicStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.metadata.bookkeeper.LegacyHierarchicalLedgerRangeIterator",
    "simpleClassName" : "LegacyHierarchicalLedgerRangeIterator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "threadLocalNodeBuilder",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'LegacyHierarchicalLedgerRangeIterator' uses ThreadLocal in field 'threadLocalNodeBuilder'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.structuredeventlog.slf4j.Slf4jEvent",
    "simpleClassName" : "Slf4jEvent",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "loggersTLS",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'Slf4jEvent' uses ThreadLocal in field 'loggersTLS'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.client.impl.LastCumulativeAck",
    "simpleClassName" : "LastCumulativeAck",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "LOCAL_LAST_CUMULATIVE_ACK",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'LastCumulativeAck' uses Netty FastThreadLocal in field 'LOCAL_LAST_CUMULATIVE_ACK'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.nonpersistent.NonPersistentStickyKeyDispatcherMultipleConsumers",
    "simpleClassName" : "NonPersistentStickyKeyDispatcherMultipleConsumers",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localGroupedEntries",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'NonPersistentStickyKeyDispatcherMultipleConsumers' uses Netty FastThreadLocal in field 'localGroupedEntries'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.nonpersistent.NonPersistentStickyKeyDispatcherMultipleConsumers",
    "simpleClassName" : "NonPersistentStickyKeyDispatcherMultipleConsumers",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localGroupedStickyKeyHashes",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'NonPersistentStickyKeyDispatcherMultipleConsumers' uses Netty FastThreadLocal in field 'localGroupedStickyKeyHashes'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.ServerCnx$PendingBytesPerThreadTracker",
    "simpleClassName" : "ServerCnx$PendingBytesPerThreadTracker",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "pendingBytesPerThread",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'ServerCnx$PendingBytesPerThreadTracker' uses Netty FastThreadLocal in field 'pendingBytesPerThread'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.client.impl.UnAckedMessageTracker",
    "simpleClassName" : "UnAckedMessageTracker",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "TL_MESSAGE_IDS_SET",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'UnAckedMessageTracker' uses Netty FastThreadLocal in field 'TL_MESSAGE_IDS_SET'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "simpleClassName" : "PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localGroupedEntries",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'PersistentStickyKeyDispatcherMultipleConsumersClassic' uses Netty FastThreadLocal in field 'localGroupedEntries'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.persistent.PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "simpleClassName" : "PersistentStickyKeyDispatcherMultipleConsumersClassic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localGroupedPositions",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'PersistentStickyKeyDispatcherMultipleConsumersClassic' uses Netty FastThreadLocal in field 'localGroupedPositions'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.client.impl.ConsumerImpl",
    "simpleClassName" : "ConsumerImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "LOCAL_BASE_COMMAND",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'ConsumerImpl' uses Netty FastThreadLocal in field 'LOCAL_BASE_COMMAND'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.tests.FastThreadLocalStateCleaner",
    "simpleClassName" : "FastThreadLocalStateCleaner",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "SLOW_THREAD_LOCAL_MAP",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'FastThreadLocalStateCleaner' uses ThreadLocal in field 'SLOW_THREAD_LOCAL_MAP'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.transaction.pendingack.impl.MLPendingAckStore",
    "simpleClassName" : "MLPendingAckStore",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "batchedMetaThreadLocalForBufferedWriter",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'MLPendingAckStore' uses Netty FastThreadLocal in field 'batchedMetaThreadLocalForBufferedWriter'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.reader.AvroReader",
    "simpleClassName" : "AvroReader",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "decoders",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'AvroReader' uses ThreadLocal in field 'decoders'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.SendMessageInfo",
    "simpleClassName" : "SendMessageInfo",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "THREAD_LOCAL",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'SendMessageInfo' uses Netty FastThreadLocal in field 'THREAD_LOCAL'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.TransactionAggregator",
    "simpleClassName" : "TransactionAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localTransactionCoordinatorStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'TransactionAggregator' uses Netty FastThreadLocal in field 'localTransactionCoordinatorStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.TransactionAggregator",
    "simpleClassName" : "TransactionAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localManageLedgerStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'TransactionAggregator' uses Netty FastThreadLocal in field 'localManageLedgerStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.impl.LoadManagerShared",
    "simpleClassName" : "LoadManagerShared",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localSecondaryCache",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'LoadManagerShared' uses Netty FastThreadLocal in field 'localSecondaryCache'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.impl.LoadManagerShared",
    "simpleClassName" : "LoadManagerShared",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localPrimariesCache",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'LoadManagerShared' uses Netty FastThreadLocal in field 'localPrimariesCache'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator",
    "simpleClassName" : "NamespaceStatsAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localTopicStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'NamespaceStatsAggregator' uses Netty FastThreadLocal in field 'localTopicStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator",
    "simpleClassName" : "NamespaceStatsAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localBrokerStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'NamespaceStatsAggregator' uses Netty FastThreadLocal in field 'localBrokerStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.NamespaceStatsAggregator",
    "simpleClassName" : "NamespaceStatsAggregator",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localNamespaceStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'NamespaceStatsAggregator' uses Netty FastThreadLocal in field 'localNamespaceStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.metrics.DataSketchesSummaryLogger$ThreadLocalAccessor",
    "simpleClassName" : "DataSketchesSummaryLogger$ThreadLocalAccessor",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localData",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'DataSketchesSummaryLogger$ThreadLocalAccessor' uses Netty FastThreadLocal in field 'localData'. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.tests.MockitoThreadLocalStateCleaner",
    "simpleClassName" : "MockitoThreadLocalStateCleaner",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "MOCKING_PROGRESS_PROVIDER",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'MockitoThreadLocalStateCleaner' uses ThreadLocal in field 'MOCKING_PROGRESS_PROVIDER'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.web.JettyRequestLogFactory$OriginalClientIPRequestLog",
    "simpleClassName" : "JettyRequestLogFactory$OriginalClientIPRequestLog",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "requestLogStringBuilder",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'JettyRequestLogFactory$OriginalClientIPRequestLog' uses ThreadLocal in field 'requestLogStringBuilder'. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.extensions.strategy.LeastResourceUsageWithWeight",
    "simpleClassName" : "LeastResourceUsageWithWeight",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "noLoadDataBrokers",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'LeastResourceUsageWithWeight' uses ThreadLocal in field 'noLoadDataBrokers'. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.loadbalance.extensions.strategy.LeastResourceUsageWithWeight",
    "simpleClassName" : "LeastResourceUsageWithWeight",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "ThreadLocal storage: ThreadLocal",
    "fieldName" : "bestBrokers",
    "fieldType" : "Ljava/lang/ThreadLocal;",
    "description" : "Class 'LeastResourceUsageWithWeight' uses ThreadLocal in field 'bestBrokers'. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to ThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If ThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.stats.prometheus.metrics.DataSketchesOpStatsLogger$ThreadLocalAccessor",
    "simpleClassName" : "DataSketchesOpStatsLogger$ThreadLocalAccessor",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "MEDIUM",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localData",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'DataSketchesOpStatsLogger$ThreadLocalAccessor' uses Netty FastThreadLocal in field 'localData'. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.ServerCnx",
    "simpleClassName" : "ServerCnx",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "cnxsPerThread",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'ServerCnx' uses Netty FastThreadLocal in field 'cnxsPerThread'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.transaction.coordinator.impl.MLTransactionLogImpl",
    "simpleClassName" : "MLTransactionLogImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "localBatchedTransactionLogCache",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'MLTransactionLogImpl' uses Netty FastThreadLocal in field 'localBatchedTransactionLogCache'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.client.impl.MessageIdImpl",
    "simpleClassName" : "MessageIdImpl",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "LOCAL_MESSAGE_ID",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'MessageIdImpl' uses Netty FastThreadLocal in field 'LOCAL_MESSAGE_ID'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.client.impl.schema.StringSchema",
    "simpleClassName" : "StringSchema",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "tmpBuffer",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'StringSchema' uses Netty FastThreadLocal in field 'tmpBuffer'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.broker.service.nonpersistent.NonPersistentTopic",
    "simpleClassName" : "NonPersistentTopic",
    "stateType" : "IN_MEMORY",
    "riskLevel" : "HIGH",
    "pattern" : "ThreadLocal storage: Netty FastThreadLocal",
    "fieldName" : "threadLocalTopicStats",
    "fieldType" : "Lio/netty/util/concurrent/FastThreadLocal;",
    "description" : "Class 'NonPersistentTopic' uses Netty FastThreadLocal in field 'threadLocalTopicStats'. Static ThreadLocal is shared across the JVM but state is per-thread. This can cause issues with: (1) async/reactive code where context is lost, (2) thread pool reuse where old context leaks, (3) load balancer routing where requests hit different threads.",
    "recommendation" : "Consider alternatives to Netty FastThreadLocal: (1) Pass context explicitly through method parameters, (2) Use request-scoped injection instead, (3) For reactive code, use context propagation (e.g., Reactor Context). If Netty FastThreadLocal is necessary, ensure proper cleanup in finally blocks.",
    "detectorId" : "threadlocal"
  }, {
    "className" : "org.apache.pulsar.io.kafka.KafkaAbstractSource$KafkaRecord",
    "simpleClassName" : "KafkaAbstractSource$KafkaRecord",
    "stateType" : "EXTERNAL",
    "riskLevel" : "MEDIUM",
    "pattern" : "Kafka messaging",
    "fieldName" : "record",
    "fieldType" : "Lorg/apache/kafka/clients/consumer/ConsumerRecord;",
    "description" : "Class 'KafkaAbstractSource$KafkaRecord' has KAFKA dependency via field 'record'. Kafka provides durable messaging but partition assignment affects scaling.",
    "recommendation" : "Review partition strategy for horizontal scaling. Consider consumer group configuration.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.kafka.KafkaAbstractSource",
    "simpleClassName" : "KafkaAbstractSource",
    "stateType" : "EXTERNAL",
    "riskLevel" : "MEDIUM",
    "pattern" : "Kafka messaging",
    "fieldName" : "consumer",
    "fieldType" : "Lorg/apache/kafka/clients/consumer/Consumer;",
    "description" : "Class 'KafkaAbstractSource' has KAFKA dependency via field 'consumer'. Kafka provides durable messaging but partition assignment affects scaling.",
    "recommendation" : "Review partition strategy for horizontal scaling. Consider consumer group configuration.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.kafka.KafkaAbstractSink",
    "simpleClassName" : "KafkaAbstractSink",
    "stateType" : "EXTERNAL",
    "riskLevel" : "MEDIUM",
    "pattern" : "Kafka messaging",
    "fieldName" : "producer",
    "fieldType" : "Lorg/apache/kafka/clients/producer/Producer;",
    "description" : "Class 'KafkaAbstractSink' has KAFKA dependency via field 'producer'. Kafka provides durable messaging but partition assignment affects scaling.",
    "recommendation" : "Review partition strategy for horizontal scaling. Consider consumer group configuration.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.jdbc.JdbcAbstractSink",
    "simpleClassName" : "JdbcAbstractSink",
    "stateType" : "EXTERNAL",
    "riskLevel" : "LOW",
    "pattern" : "Database connection",
    "fieldName" : "connection",
    "fieldType" : "Ljava/sql/Connection;",
    "description" : "Class 'JdbcAbstractSink' has DATABASE dependency via field 'connection'. This is the recommended way to manage shared state.",
    "recommendation" : "Ensure connection pooling is configured for horizontal scaling.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.rabbitmq.RabbitMQSink",
    "simpleClassName" : "RabbitMQSink",
    "stateType" : "EXTERNAL",
    "riskLevel" : "LOW",
    "pattern" : "Database connection",
    "fieldName" : "rabbitMQConnection",
    "fieldType" : "Lcom/rabbitmq/client/Connection;",
    "description" : "Class 'RabbitMQSink' has DATABASE dependency via field 'rabbitMQConnection'. This is the recommended way to manage shared state.",
    "recommendation" : "Ensure connection pooling is configured for horizontal scaling.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.rabbitmq.RabbitMQSink",
    "simpleClassName" : "RabbitMQSink",
    "stateType" : "EXTERNAL",
    "riskLevel" : "MEDIUM",
    "pattern" : "RabbitMQ messaging",
    "fieldName" : "rabbitMQChannel",
    "fieldType" : "Lcom/rabbitmq/client/Channel;",
    "description" : "Class 'RabbitMQSink' has RABBITMQ dependency via field 'rabbitMQChannel'. RabbitMQ supports horizontal scaling with proper queue configuration.",
    "recommendation" : "Configure queues appropriately for competing consumers across replicas.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.rabbitmq.RabbitMQSource",
    "simpleClassName" : "RabbitMQSource",
    "stateType" : "EXTERNAL",
    "riskLevel" : "MEDIUM",
    "pattern" : "RabbitMQ messaging",
    "fieldName" : "rabbitMQChannel",
    "fieldType" : "Lcom/rabbitmq/client/Channel;",
    "description" : "Class 'RabbitMQSource' has RABBITMQ dependency via field 'rabbitMQChannel'. RabbitMQ supports horizontal scaling with proper queue configuration.",
    "recommendation" : "Configure queues appropriately for competing consumers across replicas.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.rabbitmq.RabbitMQSource",
    "simpleClassName" : "RabbitMQSource",
    "stateType" : "EXTERNAL",
    "riskLevel" : "LOW",
    "pattern" : "Database connection",
    "fieldName" : "rabbitMQConnection",
    "fieldType" : "Lcom/rabbitmq/client/Connection;",
    "description" : "Class 'RabbitMQSource' has DATABASE dependency via field 'rabbitMQConnection'. This is the recommended way to manage shared state.",
    "recommendation" : "Ensure connection pooling is configured for horizontal scaling.",
    "detectorId" : "external-state"
  }, {
    "className" : "org.apache.pulsar.io.http.HttpSink",
    "simpleClassName" : "HttpSink",
    "stateType" : "SERVICE_CLIENT",
    "riskLevel" : "INFO",
    "pattern" : "HTTP client: Java HttpClient",
    "fieldName" : "httpClient",
    "fieldType" : "Ljava/net/http/HttpClient;",
    "description" : "Class 'HttpSink' uses Java HttpClient HTTP client in field 'httpClient'. Java 11+ HttpClient is thread-safe and pools connections.",
    "recommendation" : "Java HttpClient is safe for horizontal scaling. Review connection pool settings.",
    "detectorId" : "service-client"
  }, {
    "className" : "org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntime",
    "simpleClassName" : "KubernetesRuntime",
    "stateType" : "SERVICE_CLIENT",
    "riskLevel" : "INFO",
    "pattern" : "gRPC client",
    "fieldName" : "channel",
    "fieldType" : "[Lio/grpc/ManagedChannel;",
    "description" : "Class 'KubernetesRuntime' uses ManagedChannel in field 'channel'. gRPC clients maintain connection state but are typically safe for horizontal scaling.",
    "recommendation" : "gRPC channels are typically safe to share across replicas. Ensure load balancing is configured appropriately for the target service.",
    "detectorId" : "service-client"
  }, {
    "className" : "org.apache.pulsar.functions.runtime.process.ProcessRuntime",
    "simpleClassName" : "ProcessRuntime",
    "stateType" : "SERVICE_CLIENT",
    "riskLevel" : "INFO",
    "pattern" : "gRPC client",
    "fieldName" : "channel",
    "fieldType" : "Lio/grpc/ManagedChannel;",
    "description" : "Class 'ProcessRuntime' uses ManagedChannel in field 'channel'. gRPC clients maintain connection state but are typically safe for horizontal scaling.",
    "recommendation" : "gRPC channels are typically safe to share across replicas. Ensure load balancing is configured appropriately for the target service.",
    "detectorId" : "service-client"
  }, {
    "className" : "org.apache.pulsar.functions.runtime.JavaInstanceStarter",
    "simpleClassName" : "JavaInstanceStarter",
    "stateType" : "SERVICE_CLIENT",
    "riskLevel" : "INFO",
    "pattern" : "gRPC client",
    "fieldName" : "server",
    "fieldType" : "Lio/grpc/Server;",
    "description" : "Class 'JavaInstanceStarter' uses gRPC component in field 'server'. gRPC clients maintain connection state but are typically safe for horizontal scaling.",
    "recommendation" : "gRPC channels are typically safe to share across replicas. Ensure load balancing is configured appropriately for the target service.",
    "detectorId" : "service-client"
  }, {
    "className" : "org.apache.pulsar.client.impl.auth.AuthenticationSasl",
    "simpleClassName" : "AuthenticationSasl",
    "stateType" : "SERVICE_CLIENT",
    "riskLevel" : "INFO",
    "pattern" : "HTTP client: JAX-RS Client",
    "fieldName" : "client",
    "fieldType" : "Ljavax/ws/rs/client/Client;",
    "description" : "Class 'AuthenticationSasl' uses JAX-RS Client HTTP client in field 'client'. JAX-RS clients are typically stateless and safe for horizontal scaling.",
    "recommendation" : "Ensure connection pool is sized appropriately for replica count.",
    "detectorId" : "service-client"
  } ]
}